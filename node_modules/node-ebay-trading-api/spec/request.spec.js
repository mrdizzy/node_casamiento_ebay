var vows = require('vows'),
    assert = require('assert'),
    http = require('https'),
    eBayTradingAPI = require('./../index'),
    sinon = require('sinon'),
    EventEmitter = require('events').EventEmitter,
    fs = require('fs');

var appId = 'Appid-1111-1111-1111-111111111111',
    devId = '22222222-2222-2222-2222-222222222222',
    siteId = '3',
    certId = '444444444-4444-4444-4444-444444444444',
    authToken = '555555**555555**555555**555555**';

var api = new eBayTradingAPI(appId, siteId, devId, certId, authToken);

var fakeRequest = function(name, cb) {
        fs.readFile(__dirname + '/fixtures/' + name + '.xml', 'utf-8', function(err, res) {
            fakeResponse(res);
            cb(err, res);
        });
    }
vows.describe("eBay Trading API").addBatch({
    "when a response returns an error message": {
        topic: function() {
            var self = this;
            fakeRequest("failure_auth_token_is_invalid", function(err, res) {
                api.makeRequest("GetOrders", self.callback);
            });
        },
        "an error should be returned": function(err, result) {
            assert.isNotNull(err);
        },
        teardown: function() {
            http.request.restore()
        }
    }

}).addBatch({
    "when a response is returned with invalid xml": {
        topic: function() {
            var self = this;
            fakeRequest("invalid_xml", function(err, res) {
                api.makeRequest("GetOrders", self.callback, null, "json");
            });
        },
        "an error should be returned": function(err, result) {
            assert.isNotNull(err);
        }
    },
    teardown: function() {
        http.request.restore()
    }
}).addBatch({
    "when a successful request is made in json": {
        topic: function() {
            var self = this;
            fakeRequest("my_messages_response", function(err, res) {
                api.makeRequest("GetMyMessages", self.callback, null, "json");
            });
        },
        "the Timestamp attribute should be correct": function(result) {
            assert.equal(result["Timestamp"], "2012-04-24T11:57:58.102Z", "Timestamp is not correct");
        },
        "the Messages => Message attribute should be an array": function(result) {
            assert(result["Messages"]["Message"].length);
        },
        "the subject of the last Message should be correct": function(result) {
            var messages = result["Messages"]["Message"];
            assert.equal(messages[messages.length - 1]["Subject"], "Important news for sellers", messages[messages.length - 1]["Subject"])
        }
    },
    teardown: function() {
        http.request.restore()
    }
}).addBatch({
    "When making request": {
        topic: function() {
                self = this;
            var xmlRequest = api.makeRequest("GetOrders", function(err, res) {
                self.callback(err, res, xmlRequest);
            }, {
                OrderIDArray: {
                    OrderID: [109328352017, "251035045087-0", "251036250196-0"]
                },
                OutputSelector: ["OrderArray.Order.OrderID", "OrderArray.Order.TransactionArray.Transaction.Item"],
                Pagination: {
                    EntriesPerPage: 25,
                    PageNumber: 3
                }
            }, "json");
        },
        "there should be a good request": function(err, result, spy) {
            fs.readFile(__dirname + '/fixtures/requests/get_orders_request.xml', 'utf-8', function(err, res) {
                console.log("Spy", spy);
                console.log(res);
            })
        }
    }
}).run();

var fakeResponse = function(xml) {
        var spy = sinon.stub(http, "request", function(options, callback) {
            var emitter = new EventEmitter();
            callback(emitter);
            emitter.emit('data', xml);
            emitter.emit('end');
            var req = {
                write: function() {},
                end: function() {}
            };
            return (req);
        });
    }