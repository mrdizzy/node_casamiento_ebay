var db = require('./database_config'),
    eBayAPI = require('./ebay_configuration'),
    _ = require('underscore');

module.exports = ImportOrders;

ImportOrders(db, eBayAPI, function(err, res) {
    console.log(res);
})

function ImportOrders(db, eBayAPI, cb) {
    db.get('time', function(err, res) { // Get last imported time and begin import
        if (err) {
            console.log("Could not get last imported time: ", err);
        }
        else {
            eBayAPI.makeRequest("GetOrders", function(err,res) {
                    GetOrdersFromEbay(err,res, cb);
                }, {
                ModTimeFrom: res.lastModified,
                ModTimeTo: new Date().toISOString()
            }, "json");
        }
    });
}

function GetOrdersFromEbay(err, res, cb) {
    if (res.ReturnedOrderCountActual === '0') {
        console.log("No orders to import");
        return;
    }

    // Normalize orders, so even single orders are in an array

    var orders = res.OrderArray.Order.length ? res.OrderArray.Order : [res.OrderArray.Order],
        waiting = orders.length;

    var orderResults = Parser(orders),
        parsedOrders = orderResults[0],
        lineItemIDs = orderResults[1];

    parsedOrders.forEach(function(order) {
        db.save(order, function(error, response) {
            if (err) {
                console.log("Unable to save raw orders. Error: " + error.error + " Reason: " + error.reason);
            }
            else {
                waiting--;
                if (!waiting) {
                    updateTime(res.Timestamp, lineItemIDs, cb);
                    console.log("Completed");
                }
            }
        })
    })
}

function updateTime(timeStamp, lineItemIDs, cb) {
    db.save('time', {
        lastModified: timeStamp
    }, function(err, res) {
        if (err) {
            console.log("Unable to update time:" + err.reason);
        }
        else {
            console.log("Updated time", res);
            combineOrders(lineItemIDs, cb);
        }
    });
}
function combineOrders(lineItemIDs, cb) {
    var waiting = lineItemIDs.length;
    if (lineItemIDs.length > 0) {
        db.get(lineItemIDs, function(err, res) {
            res.forEach(function(order) {
                if (order.error) {
                    waiting--;
                    if (!waiting) {
                        cb(null, true);
                    }
                }
                else {
                    db.remove(order._id, order._rev, function(e, r) {
                        waiting--;
                        if (!waiting) {
                            cb(null, true);
                        }
                    })
                }
            });
        });
    }
    else {
        cb(null, true)
    }
}

function Parser(orders) {
    var lineItemIDs = [],
        parsedOrders = _.collect(orders, function(obj) {
            var newObj = {},
                transactions = obj.TransactionArray.Transaction.length ? obj.TransactionArray.Transaction : [obj.TransactionArray.Transaction];

            newObj._id = obj.OrderID;
            newObj.createdTime = obj.CreatedTime;
            newObj.shippingAddress = obj.ShippingAddress
            newObj.EIASToken - obj.EIASToken;
            newObj.BuyerUserID = obj.BuyerUserID;
            newObj.SubTotal = (obj.Subtotal["#"]);
            newObj.Total = (obj.Total["#"]);

            newObj.Transactions = _.collect(transactions, function(t) {
                var newTransaction = {};
                if (!(obj.OrderID.match(/-/))) {
                    lineItemIDs.push(t.OrderLineItemID);
                }
                newTransaction.quantity = t.QuantityPurchased;
                newTransaction.TransactionID = t.TransactionID;
                newTransaction.price = t.TransactionPrice["#"];
                newTransaction.lineItemID = t.OrderLineItemID;
                return newTransaction;
            });
            return newObj;
        })
        return ([parsedOrders, lineItemIDs]);
}